'use client'

import {
  CubicBezierLine,
  Html,
  Line,
  PointMaterial,
  Points,
  ScrollControls,
  Stars,
  Text,
  useFBO,
  useScroll,
  useTexture,
} from '@react-three/drei'
import { Canvas, useFrame, useThree } from '@react-three/fiber'
import * as random from 'maath/random/dist/maath-random.esm'
import { useEffect, useMemo, useRef, useState } from 'react'
import * as THREE from 'three'
import { MathUtils, Vector3 } from 'three'

import { DogEar } from '@/components/DogEar'

import styles from './dev-history.module.css'
import { devHistoryData } from '@/data/dev-history-data'
import { useStore } from '@/stores/useStore'

// --- Black Hole GLSL Shader Code ---
const blackHoleVertexShader = `
  varying vec3 v_worldPosition;
  void main() {
    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    v_worldPosition = worldPosition.xyz;
    gl_Position = projectionMatrix * viewMatrix * worldPosition;
  }
`

const blackHoleFragmentShader = `
  uniform sampler2D u_scene_texture;
  uniform vec2 u_resolution;
  uniform float u_strength;
  varying vec3 v_worldPosition;
  
  void main() {
    vec2 screen_uv = gl_FragCoord.xy / u_resolution;
    vec2 centered_uv = screen_uv - 0.5;
    float dist = length(centered_uv);
    
    // Gravitational lensing effect
    vec2 distorted_uv = screen_uv + normalize(centered_uv) * u_strength * (1.0 - dist);
    
    vec4 scene_color = texture2D(u_scene_texture, distorted_uv);
    
    // Create the black hole and a glowing accretion disk
    float hole = 1.0 - smoothstep(0.0, 0.1, dist);
    float disk = smoothstep(0.1, 0.11, dist) - smoothstep(0.12, 0.13, dist);
    
    vec3 color = scene_color.rgb * hole;
    color += vec3(1.0, 0.5, 0.1) * disk * 2.0; // Orange glow
    
    gl_FragColor = vec4(color, 1.0);
  }
`

function Scene() {
  const { viewport, size, scene, camera } = useThree()
  const universeState = useStore((state) => state.universeState)
  const blackHoleRenderTarget = useFBO()
  const blackHoleMaterialRef = useRef()

  useFrame((state) => {
    if (universeState !== 'flight') {
      state.gl.setRenderTarget(blackHoleRenderTarget)
      state.gl.render(scene, camera) // Render the 3D scene to a texture

      if (blackHoleMaterialRef.current) {
        blackHoleMaterialRef.current.uniforms.uSceneTexture.value = blackHoleRenderTarget.texture
        let strength = 0
        if (universeState === 'singularity') strength = 0.1
        if (universeState === 'dive') strength = 1.0 // Max distortion during dive
        blackHoleMaterialRef.current.uniforms.uStrength.value = MathUtils.lerp(
          blackHoleMaterialRef.current.uniforms.uStrength.value,
          strength,
          0.1
        )
      }
      state.gl.setRenderTarget(null) // Render back to screen
    }
  })

  return (
    <>
      <ambientLight intensity={0.5} />
      <directionalLight position={[10, 10, 5]} intensity={1} />
      {/* We only render the stars if we're in flight mode */}
      {universeState === 'flight' && <Stars count={5000} />}

      {devHistoryData.map((node) => (
        <ArtifactNode key={node.id} {...node} />
      ))}
      <CameraRig />

      {/* The Black Hole Post-Processing Effect */}
      {universeState !== 'flight' && (
        <mesh>
          <planeGeometry args={[viewport.width, viewport.height]} />
          <shaderMaterial
            ref={blackHoleMaterialRef}
            vertexShader={blackHoleVertexShader}
            fragmentShader={blackHoleFragmentShader}
            uniforms={{
              uSceneTexture: { value: null },
              uStrength: { value: 0 },
            }}
          />
        </mesh>
      )}
    </>
  )
}

function ArtifactNode({ id, title, year, position }) {
  const groupRef = useRef()
  const { universeState } = useStore()
  const isActive = useStore((state) => state.selectedNode === id)
  const finalNodePosition = new Vector3(...devHistoryData[devHistoryData.length - 1].position)
  const isEndgame = universeState === 'endgame'
  const textRef = useRef()

  useFrame((state, delta) => {
    if (isEndgame && textRef.current && textRef.current.material) {
      textRef.current.material.emissiveIntensity = MathUtils.lerp(textRef.current.material.emissiveIntensity, 2, 0.1)
      textRef.current.material.color.lerp(new THREE.Color('#ffff00'), 0.1)
    }
    // if (!groupRef.current) return
    // if (universeState === 'unraveling') {
    //   // Fly towards the final node
    //   groupRef.current.position.lerp(finalNodePosition, delta * 0.5)
    //   groupRef.current.scale.lerp(new Vector3(0, 0, 0), delta * 0.5)
    // } else if (universeState === 'flight') {
    //   // Normal behavior
    //   const scale = isActive ? 1.2 : 1
    //   groupRef.current.scale.lerp(new Vector3(scale, scale, scale), 0.1)
    // }
  })

  return (
    <group ref={groupRef} position={position}>
      <Text
        ref={textRef}
        position={[0, 0.5, 0]}
        fontSize={0.5}
        color="white"
        // color={isEndgame ? '#ffff00' : '#fff'}
        // material-emissive={isEndgame ? '#ffff00' : '#000'}
        // material-emissiveIntensity={isEndgame ? 2 : 0}
        // material-toneMapped={false}
        // material-transparent={true}
        // material-opacity={1.0 - Math.pow(useStore.getState().launchProgress || 0, 2)}
      >
        {title}
      </Text>
      <Text
        position={[0, -0.5, 0]}
        fontSize={0.25}
        color="#999"
        material-transparent={true}
        material-opacity={1.0 - Math.pow(useStore.getState().launchProgress || 0, 2)}
      >
        {year}
      </Text>
    </group>
  )
}

// --- COMPONENT 2: The Camera & State Controller ---
function CameraRig() {
  const { camera, scene } = useThree()
  const scroll = useScroll()
  const { universeState, actions } = useStore()
  const [shutdownTriggered, setShutdownTriggered] = useState(false)
  const [endgameTriggered, setEndgameTriggered] = useState(false)

  useFrame((state, delta) => {
    // // TRIGGER
    // if (scroll.offset > 0.999 && !shutdownTriggered && universeState === 'flight') {
    //   setShutdownTriggered(true)
    //   actions.beginUnraveling()
    //   setTimeout(actions.formSingularity, 3000) // 3s for unraveling
    //   setTimeout(actions.dive, 4500) // 1.5s for singularity
    //   setTimeout(actions.enterVoid, 6500) // 2s for dive
    // }

    if (scroll.offset > 0.999 && !endgameTriggered) {
      actions.beginEndgame()
      setEndgameTriggered(true)
    }

    if (universeState === 'endgame') {
      const wideShotPosition = new Vector3(0, 5, 20) // A position far enough to see everything
      state.camera.position.lerp(wideShotPosition, delta * 0.5)
      state.camera.lookAt(0, 5, 0) // Look at the center of the cosmos
    } else {
      //   // --- NORMAL FLIGHT LOGIC ---
      //   // ... your existing, stable flight logic remains here ...
      // Standard flight logic from our stable version
      const offset = MathUtils.clamp(scroll.offset, 0, 1)
      const sectionIndex = Math.floor(offset * (devHistoryData.length - 1))
      const nextSectionIndex = Math.min(sectionIndex + 1, devHistoryData.length - 1)
      const startNode = new Vector3(...devHistoryData[sectionIndex].position)
      const endNode = new Vector3(...devHistoryData[nextSectionIndex].position)
      const sectionProgress = (offset * (devHistoryData.length - 1)) % 1
      const cameraTarget = new Vector3()
      cameraTarget.lerpVectors(startNode, endNode, sectionProgress)
      cameraTarget.x += state.pointer.x * 0.5
      cameraTarget.y += state.pointer.y * 0.5
      cameraTarget.z += 5
      state.camera.position.lerp(cameraTarget, delta * 2)
      const lookAtTarget = new Vector3()
      lookAtTarget.lerpVectors(startNode, endNode, sectionProgress)
      state.camera.lookAt(lookAtTarget)
    }

    // // Animate based on state
    // if (universeState === 'flight') {
    //   // Standard flight logic from our stable version
    //   const offset = MathUtils.clamp(scroll.offset, 0, 1)
    //   const sectionIndex = Math.floor(offset * (devHistoryData.length - 1))
    //   const nextSectionIndex = Math.min(sectionIndex + 1, devHistoryData.length - 1)
    //   const startNode = new Vector3(...devHistoryData[sectionIndex].position)
    //   const endNode = new Vector3(...devHistoryData[nextSectionIndex].position)
    //   const sectionProgress = (offset * (devHistoryData.length - 1)) % 1
    //   const cameraTarget = new Vector3()
    //   cameraTarget.lerpVectors(startNode, endNode, sectionProgress)
    //   cameraTarget.x += state.pointer.x * 0.5
    //   cameraTarget.y += state.pointer.y * 0.5
    //   cameraTarget.z += 5
    //   state.camera.position.lerp(cameraTarget, delta * 2)
    //   const lookAtTarget = new Vector3()
    //   lookAtTarget.lerpVectors(startNode, endNode, sectionProgress)
    //   state.camera.lookAt(lookAtTarget)
    // } else if (universeState === 'unraveling' || universeState === 'singularity') {
    //   // Hold camera steady, looking at the final node as everything collapses
    //   const finalNodePosition = new Vector3(...devHistoryData[devHistoryData.length - 1].position)
    //   const cameraTarget = new Vector3(finalNodePosition.x, finalNodePosition.y, finalNodePosition.z + 10)
    //   state.camera.position.lerp(cameraTarget, delta * 1)
    //   state.camera.lookAt(finalNodePosition)
    // } else if (universeState === 'dive') {
    //   // Fly into the singularity
    //   const finalNodePosition = new Vector3(...devHistoryData[devHistoryData.length - 1].position)
    //   state.camera.position.lerp(finalNodePosition, delta * 1.5)
    //   state.camera.lookAt(finalNodePosition)
    // }
  })

  return null
}

function Bridge() {
  const ref = useRef()
  const { camera } = useThree()
  const { universeState } = useStore()

  useFrame(() => {
    if (universeState === 'endgame' && ref.current && ref.current.material) {
      // Animate the line's end point from the last node to the camera
      const finalNodePos = new Vector3(...devHistoryData[devHistoryData.length - 1].position)
      // ref.current.end.lerp(camera.position, 0.05)
      // ref.current.start.copy(finalNodePos)
      ref.current.lookAt(camera.position)
      const targetScale = ref.current.position.distanceTo(camera.position)
      ref.current.scale.z = MathUtils.lerp(ref.current.scale.z, targetScale, 0.05)
    }
  })
  // We'll use a simple cylinder for the bridge now.
  const startPoint = new Vector3(...devHistoryData[devHistoryData.length - 1].position)
  return (
    <mesh ref={ref} position={startPoint} scale-z={0}>
      <cylinderGeometry args={[0.05, 0.05, 1, 8]} />
      <meshBasicMaterial color="white" toneMapped={false} />
    </mesh>
  )
  // // Start the line as a single point at the last node's position
  // const startPoint = new Vector3(...devHistoryData[devHistoryData.length - 1].position)
  // return <Line ref={ref} points={[startPoint, startPoint]} color="white" lineWidth={5} />
}

function Blueprint({ isActive }) {
  const ref = useRef()

  useFrame((state, delta) => {
    if (ref.current) {
      // Give it a constant, slow rotation
      ref.current.rotation.x += delta * 0.1
      ref.current.rotation.y += delta * 0.2

      // Animate the scale based on the active state
      const targetScale = isActive ? 1 : 0
      ref.current.scale.lerp(new Vector3(targetScale, targetScale, targetScale), delta * 2)
    }
  })

  return (
    <group ref={ref} scale={0}>
      {/* We use an Icosahedron for a complex, futuristic look */}
      <mesh>
        <icosahedronGeometry args={[5, 1]} /> {/* 5 radius, 1 detail */}
        <meshBasicMaterial color="#ffff00" wireframe={true} />
      </mesh>
    </group>
  )
}

function LivingAssembler({ isActive }) {
  const groupRef = useRef()
  const cubesRef = useRef([])
  const { universeState } = useStore() // Get the global state
  const isEndgame = universeState === 'endgame'

  // Create a set number of cubes for our swarm
  const numCubes = 50

  // Initialize random data for each cube's chaotic movement
  const cubeData = useMemo(
    () =>
      [...Array(numCubes)].map(() => ({
        position: new Vector3().setFromSphericalCoords(2, Math.random() * Math.PI, Math.random() * 2 * Math.PI),
        rotationSpeed: (Math.random() - 0.5) * 0.02,
      })),
    []
  )

  useFrame((state, delta) => {
    cubesRef.current.forEach((cube, i) => {
      if (cube) {
        const data = cubeData[i]
        let targetPosition // This will hold the cube's destination

        // Animate the cube's individual rotation
        cube.rotation.y += data.rotationSpeed
        cube.rotation.x += data.rotationSpeed

        if (isEndgame) {
          // --- ENDGAME STATE ---
          // The artifact's true awakening: all cubes collapse to the center
          targetPosition = new Vector3(0, 0, 0)
        } else if (isActive) {
          // --- ACTIVE (IN-FOCUS) STATE ---
          // Assemble into a perfect larger cube
          const sideLength = Math.cbrt(numCubes)
          const x = (i % 4) - 1.5
          const y = (Math.floor(i / 4) % 4) - 1.5
          const z = Math.floor(i / 16) - 1.5
          targetPosition = new Vector3(x, y, z).multiplyScalar(0.5)
        } else {
          // --- INACTIVE STATE ---
          // Default to its random, chaotic orbit position
          targetPosition = data.position
        }

        // Smoothly move the cube towards its calculated target position
        cube.position.lerp(targetPosition, delta * 2.0)
      }
    })
  })

  return (
    <group ref={groupRef}>
      {/* Render all the cubes in the swarm */}
      {[...Array(numCubes)].map((_, i) => (
        <mesh key={i} ref={(el) => (cubesRef.current[i] = el)}>
          <boxGeometry args={[0.2, 0.2, 0.2]} />
          <meshStandardMaterial
            color="#00ff00"
            emissive="#00ff00"
            // The glow intensifies during the endgame collapse
            emissiveIntensity={isEndgame ? 3.0 : isActive ? 1.0 : 0.2}
            transparent
            opacity={isActive || isEndgame ? 1.0 : 0.5}
            toneMapped={false}
          />
        </mesh>
      ))}

      {/* The Blueprint is always here, waiting to be activated */}
      <Blueprint isActive={isEndgame} />
    </group>
  )
}

// function LivingAssembler({ isActive }) {
//   // ... existing refs and data ...
//   const { universeState } = useStore()
//   const isEndgame = universeState === 'endgame'
//   useFrame((state, delta) => {
//     if (isEndgame) {
//       // --- ENDGAME ANIMATION ---
//       // All cubes violently fly towards the center
//       cubesRef.current.forEach((cube) => {
//         if (cube) cube.position.lerp(new Vector3(0, 0, 0), delta * 5)
//       })
//     } else {
//       // --- NORMAL ANIMATION ---
//       // ... your existing assembly/swarm logic remains here ...
//     }
//   })
//   return (
//     <group>
//       {/* The existing swarm of cubes */}
//       {[...Array(numCubes)].map((_, i) => (
//         <mesh key={i} ref={(el) => (cubesRef.current[i] = el)}>
//           {/* ... */}
//         </mesh>
//       ))}
//       {/* --- The HIDDEN BLUEPRINT --- */}
//       {/* It's always here, but only scales up when endgame starts */}
//       <Blueprint isActive={isEndgame} />
//     </group>
//   )
// }

function Scanline() {
  const ref = useRef()
  const { camera } = useThree()
  const { universeState, actions } = useStore()
  const [hasNavigated, setHasNavigated] = useState(false)

  useFrame(() => {
    if (universeState === 'endgame' && ref.current) {
      // Animate the plane's position from top to bottom
      ref.current.position.y = MathUtils.lerp(ref.current.position.y, -10, 0.05)

      // Once it's past the screen, navigate
      if (ref.current.position.y < -9.5 && !hasNavigated) {
        setHasNavigated(true)
        window.location.href = '/finale'
      }
    }
  })

  // The plane starts off-screen at the top
  return (
    <mesh ref={ref} position={[0, 10, 0]}>
      <planeGeometry args={[100, 0.2]} />
      <meshBasicMaterial color="white" toneMapped={false} />
    </mesh>
  )
}

function FinaleOverlay({ isVisible }) {
  return (
    <div className={`${styles.finaleContainer} ${isVisible ? styles.isVisible : ''}`}>
      <h1>WHERE TO NEXT?</h1>
      <div className={styles.links}>
        <a href="https://github.com/karwanleong" target="_blank" rel="noopener noreferrer">
          [ GitHub ]
        </a>
        <a href="https://www.linkedin.com/in/karwanleong" target="_blank" rel="noopener noreferrer">
          [ LinkedIn ]
        </a>
      </div>
    </div>
  )
}

const cometVertexShader = `
  uniform float u_time;
  uniform float u_launch_progress;
  attribute float a_size;
  varying float v_opacity;
  void main() {
    vec4 modelPosition = modelMatrix * vec4(position, 1.0);
    // Move stars away from the camera during launch
    modelPosition.z += u_launch_progress * u_launch_progress * -500.0;
    
    // Calculate screen position for streaking effect
    vec4 viewPosition = viewMatrix * modelPosition;
    vec4 projectedPosition = projectionMatrix * viewPosition;
    
    // Stretch the star based on its distance from the center and launch progress
    vec2 screenDir = normalize(viewPosition.xy);
    viewPosition.xy += screenDir * 2.0 * u_launch_progress;
    
    gl_Position = projectionMatrix * viewPosition;
    gl_PointSize = a_size * (20.0 * u_launch_progress + 1.0);
    
    // Fade out stars as they fly past
    v_opacity = 1.0 - smoothstep(0.0, 150.0, modelPosition.z);
  }
`
const cometFragmentShader = `
  varying float v_opacity;
  void main() {
    float distance = length(gl_PointCoord - vec2(0.5));
    float strength = 1.0 - distance * 2.0;
    gl_FragColor = vec4(1.0, 1.0, 1.0, strength * v_opacity);
  }
`

function CometStars() {
  const launchProgress = useStore((state) => state.launchProgress)
  const ref = useRef()

  const [positions, sizes] = useMemo(() => {
    const pos = new Float32Array(5000 * 3)
    const sz = new Float32Array(5000)
    for (let i = 0; i < 5000; i++) {
      new Vector3()
        .setFromSphericalCoords(
          Math.random() * 200 + 50, // radius
          Math.acos(2.0 * Math.random() - 1.0), // inclination
          2.0 * Math.random() * Math.PI // azimuth
        )
        .toArray(pos, i * 3)
      sz[i] = Math.random() * 1.5 + 0.5
    }
    return [pos, sz]
  }, [])

  const uniforms = useMemo(
    () => ({
      u_time: { value: 0 },
      u_launch_progress: { value: 0 },
    }),
    []
  )

  useFrame((state) => {
    uniforms.u_time.value = state.clock.getElapsedTime()
    uniforms.u_launch_progress.value = launchProgress
  })

  return (
    <points ref={ref}>
      <bufferGeometry>
        <bufferAttribute attach="attributes-position" count={positions.length / 3} array={positions} itemSize={3} />
        <bufferAttribute attach="attributes-a_size" count={sizes.length} array={sizes} itemSize={1} />
      </bufferGeometry>
      <shaderMaterial
        vertexShader={cometVertexShader}
        fragmentShader={cometFragmentShader}
        uniforms={uniforms}
        transparent={true}
        depthWrite={false}
        blending={THREE.AdditiveBlending}
      />
    </points>
  )
}

function DescriptionOverlay() {
  const selectedNodeId = useStore((state) => state.selectedNode)
  const nodeData = devHistoryData.find((n) => n.id === selectedNodeId)

  // We add the GlitchedText component here now!
  return (
    <div className={`${styles.overlayContainer} ${selectedNodeId ? styles.isVisible : ''}`}>
      {nodeData && (
        <>
          <h2>
            {nodeData.title} ({nodeData.year})
          </h2>
          <GlitchedText text={nodeData.description} isActive={!!selectedNodeId} />
          <button className={styles.closeButton}>Scroll to Resume Journey</button>
        </>
      )}
    </div>
  )
}

function Synapse({ start, end, targetId }) {
  const activeNodeId = useStore((state) => state.selectedNode)
  // The synapse is "active" if it leads to the currently selected node
  const isActive = activeNodeId === targetId
  const { universeState } = useStore()
  const isEndgame = universeState === 'endgame'

  // --- Calculate Control Points for the Curve ---
  const midPoint = new Vector3().addVectors(start, end).multiplyScalar(0.5)
  // Add an offset to pull the curve outwards. The offset direction is based on the line's angle.
  const controlOffset = new Vector3(end.y - start.y, start.x - end.x, 0).normalize().multiplyScalar(5)

  const controlPoint1 = new Vector3().addVectors(midPoint, controlOffset)
  const controlPoint2 = new Vector3().addVectors(midPoint, controlOffset)

  return (
    <CubicBezierLine
      start={start}
      end={end}
      midA={controlPoint1} // First control point
      midB={controlPoint2} // Second control point
      lineWidth={isEndgame ? 3 : isActive ? 2.5 : 0.75}
      color="#fff" // Base color is always white
      dashed={!isEndgame && !isActive} // Only solid if active OR endgame
      // ... other dash props ...
      transparent={true}
      opacity={isEndgame ? 1.0 : isActive ? 1.0 : 0.15}
      // // --- THE AESTHETIC UPGRADE ---
      // lineWidth={isActive ? 2.5 : 1.75} // Thicker when active
      // color="#fff" // Base color is now white for opacity control
      // dashed={true}
      dashScale={isActive ? 10 : 20} // Dashes get tighter when active
      gapSize={isActive ? 5 : 8}
      // --- THE TECHNICAL FIX ---
      frustumCulled={false} // This tells the engine to ALWAYS render the line
      // // --- THE ANIMATION ---
      // // We animate the opacity to make it feel ghostly or solid
      // transparent // Use the direct 'transparent' prop
      // opacity={isActive ? 1.0 : 0.85} // Use the direct 'opacity' prop
      // // material-transparent={true}
      // // material-opacity={isActive ? 1.0 : 0.15}
      // // color={isActive ? '#00ff00' : '#8a2be2'}
      // // lineWidth={isActive ? 3 : 1}
      // // dashed={!isActive}
      // // dashScale={20}
      // // gapSize={15}
    />
    // <Line
    //   points={[start, end]}
    //   color={isActive ? '#00ff00' : '#8a2be2'} // Bright green when active, purple otherwise
    //   lineWidth={isActive ? 2.5 : 1}
    //   dashed={!isActive} // Solid when active, dashed otherwise
    //   dashScale={15}
    //   gapSize={10}
    // />
  )
}

// --- NEW: Glitched Text for the HTML Overlay ---
function GlitchedText({ text, isActive }) {
  const [displayText, setDisplayText] = useState('')
  const scrambleChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()'

  useEffect(() => {
    let interval
    if (isActive) {
      let iteration = 0
      interval = setInterval(() => {
        const newText = text
          .split('')
          .map((char, index) => {
            if (index < iteration) return text[index]
            if (char === ' ') return ' '
            return scrambleChars[Math.floor(Math.random() * scrambleChars.length)]
          })
          .join('')
        setDisplayText(newText)
        if (iteration >= text.length) clearInterval(interval)
        iteration += text.length / 45
      }, 30)
    } else {
      setDisplayText('')
    }
    return () => clearInterval(interval)
  }, [isActive, text])

  return <p>{displayText}</p>
}

function WaypointNode({ id, title, year, position }) {
  const groupRef = useRef()
  const activeNodeId = useStore((state) => state.selectedNode)
  const launchProgress = useStore((state) => state.launchProgress)
  const isActive = activeNodeId === id

  useFrame(() => {
    if (groupRef.current) {
      const scale = isActive ? 1.2 : 1
      const finalScale = scale * (1 - launchProgress)
      groupRef.current.scale.lerp(new Vector3(finalScale, finalScale, finalScale), 0.1)
    }
  })

  return (
    <group position={position} ref={groupRef}>
      <Text
        position={[0, 0.5, 0]} // Closer together now
        fontSize={0.6}
        color="#fff"
        anchorX="center"
        material-opacity={isActive ? 1.0 : 0.5}
        material-transparent={true}
      >
        {title}
      </Text>
      <Text
        position={[0, -0.5, 0]}
        fontSize={0.3}
        color="#999"
        anchorX="center"
        material-opacity={isActive ? 0.8 : 0.3}
        material-transparent={true}
      >
        {year}
      </Text>
    </group>
  )
}

// --- Nebula Component (from before) ---
function Nebula(props) {
  const ref = useRef()
  const positions = useMemo(() => {
    const sphere = new Float32Array(15000)
    random.inSphere(sphere, { radius: 150 })
    return sphere
  }, [])

  useFrame((state, delta) => {
    ref.current.rotation.x -= delta / 10
    ref.current.rotation.y -= delta / 15
    ref.current.position.x = THREE.MathUtils.lerp(ref.current.position.x, state.pointer.x * 5, 0.01)
  })

  return (
    <group rotation={[0, 0, Math.PI / 4]}>
      <Points ref={ref} positions={positions} stride={3} frustumCulled={false} {...props}>
        <PointMaterial transparent color="#8a2be2" size={0.1} sizeAttenuation={true} depthWrite={false} />
      </Points>
    </group>
  )
}
// // The STABLE CameraRig with Proximity Detection and Arrival
// function CameraRig() {
//   const [isWarping, setIsWarping] = useState(true)
//   const { camera } = useThree()
//   const scroll = useScroll()
//   const setSelectedNode = useStore((state) => state.setSelectedNode)
//   const cameraTarget = new Vector3()
//   const lookAtTarget = new Vector3()

//   const triggerShutdown = useStore((state) => state.triggerShutdown)
//   const [shutdownTriggered, setShutdownTriggered] = useState(false) // Local state to prevent re-triggering

//   const WARP_START_POS = new Vector3(10, 20, 150)
//   const NORMAL_FOV = 75
//   const WARP_FOV = 140

//   useEffect(() => {
//     camera.position.copy(WARP_START_POS)
//     camera.fov = WARP_FOV
//     camera.updateProjectionMatrix()
//     const timer = setTimeout(() => setIsWarping(false), 2500)
//     return () => clearTimeout(timer)
//   }, [camera])

//   useFrame((state, delta) => {
//     if (isWarping) {
//       const firstNodePos = new Vector3(...devHistoryData[0].position)
//       const arrivalTarget = new Vector3(firstNodePos.x, firstNodePos.y + 1, firstNodePos.z + 5)
//       state.camera.position.lerp(arrivalTarget, delta * 1.5)
//       state.camera.fov = MathUtils.lerp(state.camera.fov, NORMAL_FOV, delta * 2.0)
//       state.camera.updateProjectionMatrix()
//       state.camera.lookAt(firstNodePos)
//       return
//     }

//     const offset = MathUtils.clamp(scroll.offset, 0, 1)
//     // console.log('offset: ', offset)
//     if (offset > 0.99 && !shutdownTriggered) {
//       triggerShutdown()
//       setShutdownTriggered(true)
//     }
//     const sectionIndex = Math.floor(offset * (devHistoryData.length - 1))
//     const nextSectionIndex = Math.min(sectionIndex + 1, devHistoryData.length - 1)
//     const startNode = new Vector3(...devHistoryData[sectionIndex].position)
//     const endNode = new Vector3(...devHistoryData[nextSectionIndex].position)
//     const sectionProgress = (offset * (devHistoryData.length - 1)) % 1
//     cameraTarget.lerpVectors(startNode, endNode, sectionProgress)
//     cameraTarget.x += state.pointer.x * 0.5
//     cameraTarget.y += state.pointer.y * 0.5
//     cameraTarget.z += 5
//     state.camera.position.lerp(cameraTarget, delta * 2)
//     lookAtTarget.lerpVectors(startNode, endNode, sectionProgress)
//     state.camera.lookAt(lookAtTarget)

//     let closestNode = null
//     let minDistance = Infinity
//     const focusRadius = 12.0
//     devHistoryData.forEach((node) => {
//       const nodePosition = new Vector3(...node.position)
//       const distance = state.camera.position.distanceTo(nodePosition)
//       if (distance < minDistance) {
//         minDistance = distance
//         closestNode = node.id
//       }
//     })
//     if (minDistance < focusRadius) {
//       setSelectedNode(closestNode)
//     } else {
//       setSelectedNode(null)
//     }
//   })

//   return null
// }

// function CameraRig() {
//   const { camera } = useThree()
//   const scroll = useScroll()
//   const setLaunchProgress = useStore((state) => state.setLaunchProgress)
//   const setSelectedNode = useStore((state) => state.setSelectedNode)
//   useFrame((state, delta) => {
//     const offset = MathUtils.clamp(scroll.offset, 0, 1)
//     // Define the segments of our journey
//     const totalNodes = devHistoryData.length
//     const flightPathEnd = (totalNodes - 2) / (totalNodes - 1) // The point where we arrive at the LAST node
//     const finalNodeHold = (totalNodes - 1) / totalNodes // The start of the final launch segment
//     if (offset > finalNodeHold) {
//       // --- STATE 3: LAUNCHING TO INFINITY ---
//       const progress = MathUtils.mapLinear(offset, finalNodeHold, 1.0, 0.0, 1.0)
//       setLaunchProgress(progress)
//       setSelectedNode(null) // Ensure no node is active
//       // Let the CometStars shader handle the visual flight
//       // We can add camera shake back here if desired
//       const shakeIntensity = progress * 0.1
//       state.camera.position.x += (Math.random() - 0.5) * shakeIntensity
//       state.camera.position.y += (Math.random() - 0.5) * shakeIntensity
//     } else if (offset > flightPathEnd) {
//       // --- STATE 2: ARRIVED AT THE FINAL NODE (THE LAUNCHPAD) ---
//       setLaunchProgress(0) // Not launching yet
//       const lastNodeIndex = devHistoryData.length - 1
//       const lastNode = new Vector3(...devHistoryData[lastNodeIndex].position)
//       const cameraTarget = new Vector3()
//       cameraTarget.copy(lastNode)
//       cameraTarget.x += state.pointer.x * 0.5
//       cameraTarget.y += state.pointer.y * 0.5
//       cameraTarget.z += 5 // Hold position in front of the last node
//       state.camera.position.lerp(cameraTarget, delta * 2)
//       state.camera.lookAt(lastNode)
//       setSelectedNode(devHistoryData[lastNodeIndex].id) // Keep the last node active
//     } else {
//       // --- STATE 1: NORMAL SCROLL FLIGHT ---
//       setLaunchProgress(0)
//       // This is the standard flight logic
//       const sectionIndex = Math.floor(offset * (totalNodes - 1))
//       const nextSectionIndex = Math.min(sectionIndex + 1, totalNodes - 1)
//       const startNode = new Vector3(...devHistoryData[sectionIndex].position)
//       const endNode = new Vector3(...devHistoryData[nextSectionIndex].position)
//       const sectionProgress = (offset * (totalNodes - 1)) % 1
//       const cameraTarget = new Vector3()
//       cameraTarget.lerpVectors(startNode, endNode, sectionProgress)
//       cameraTarget.x += state.pointer.x * 0.5
//       cameraTarget.y += state.pointer.y * 0.5
//       cameraTarget.z += 5
//       state.camera.position.lerp(cameraTarget, delta * 2)
//       const lookAtTarget = new Vector3()
//       lookAtTarget.lerpVectors(startNode, endNode, sectionProgress)
//       state.camera.lookAt(lookAtTarget)
//       // Proximity logic for node activation
//       // ... (This can be kept as is, but we'll manually set the last node)
//     }
//   })

//   return null
// }

// // --- Camera Controller (with Proximity Detection) ---
// function CameraRig() {
//   const { camera } = useThree()
//   const scroll = useScroll()
//   const setLaunchProgress = useStore((state) => state.setLaunchProgress)
//   const setSelectedNode = useStore((state) => state.setSelectedNode)
//   const [isWarping, setIsWarping] = useState(true)
//   const WARP_START_POS = new Vector3(10, 20, 150)
//   const NORMAL_FOV = 75
//   const WARP_FOV = 140
//   useEffect(() => {
//     camera.position.copy(WARP_START_POS)
//     camera.fov = WARP_FOV
//     camera.updateProjectionMatrix()
//     const timer = setTimeout(() => setIsWarping(false), 2500)
//     return () => clearTimeout(timer)
//   }, [camera])
//   useFrame((state, delta) => {
//     if (isWarping) {
//       const firstNodePos = new Vector3(...devHistoryData[0].position)
//       const arrivalTarget = new Vector3(firstNodePos.x, firstNodePos.y + 1, firstNodePos.z + 5)
//       state.camera.position.lerp(arrivalTarget, delta * 1.5)
//       state.camera.fov = MathUtils.lerp(state.camera.fov, NORMAL_FOV, delta * 2.0)
//       state.camera.updateProjectionMatrix()
//       state.camera.lookAt(firstNodePos)
//       return
//     }
//     const offset = MathUtils.clamp(scroll.offset, 0, 1)
//     const launchSegmentStart = (devHistoryData.length - 1) / devHistoryData.length
//     if (offset >= launchSegmentStart) {
//       // --- THE LAUNCH SEQUENCE ---
//       const progress = MathUtils.mapLinear(offset, launchSegmentStart, 1.0, 0.0, 1.0)
//       setLaunchProgress(progress)
//       setSelectedNode(null) // Ensure no node is active during launch
//       // Vibrate the camera
//       const shakeIntensity = progress * 0.2
//       const currentPos = state.camera.position
//       currentPos.x += (Math.random() - 0.5) * shakeIntensity
//       currentPos.y += (Math.random() - 0.5) * shakeIntensity
//       // state.camera.position.x += (Math.random() - 0.5) * shakeIntensity
//       // state.camera.position.y += (Math.random() - 0.5) * shakeIntensity
//     } else {
//       // --- NORMAL SCROLL ---
//       setLaunchProgress(0)
//       const sectionIndex = Math.floor(offset * (devHistoryData.length - 1))
//       const nextSectionIndex = Math.min(sectionIndex + 1, devHistoryData.length - 1)
//       const startNode = new Vector3(...devHistoryData[sectionIndex].position)
//       const endNode = new Vector3(...devHistoryData[nextSectionIndex].position)
//       const sectionProgress = (offset * (devHistoryData.length - 1)) % 1
//       const cameraTarget = new Vector3()
//       cameraTarget.lerpVectors(startNode, endNode, sectionProgress)
//       cameraTarget.x += state.pointer.x * 0.5
//       cameraTarget.y += state.pointer.y * 0.5
//       cameraTarget.z += 5
//       state.camera.position.lerp(cameraTarget, delta * 2)
//       const lookAtTarget = new Vector3()
//       lookAtTarget.lerpVectors(startNode, endNode, sectionProgress)
//       state.camera.lookAt(lookAtTarget)
//       let closestNode = null
//       let minDistance = Infinity
//       const focusRadius = 12.0
//       devHistoryData.forEach((node) => {
//         const nodePosition = new Vector3(...node.position)
//         const distance = state.camera.position.distanceTo(nodePosition)
//         if (distance < minDistance) {
//           minDistance = distance
//           closestNode = node.id
//         }
//       })
//       if (minDistance < focusRadius) {
//         setSelectedNode(closestNode)
//       } else {
//         setSelectedNode(null)
//       }
//     }
//   })
//   return null
// }

// --- Main Page Component ---
export default function DevHistoryPage() {
  const isShutdown = useStore((state) => state.isShutdown)
  const selectedNode = useStore((state) => state.selectedNode)
  const ambientAudioRef = useRef()
  // const launchProgress = useStore((state) => state.launchProgress)

  // const [redirectToFinale, setRedirectToFinale] = useState(false)

  const { universeState } = useStore()

  // useEffect(() => {
  //   // Sound logic can be added here, tied to universeState changes
  // }, [universeState])

  useEffect(() => {
    if (universeState === 'endgame') {
      // After the animation has had time to play, navigate
      const timer = setTimeout(() => {
        // You would have a state here to fade out the whole canvas
        // and then navigate to the finale page.
        window.location.href = '/finale'
      }, 3000) // 3-second spectacle
      return () => clearTimeout(timer)
    }
  }, [universeState])

  // useEffect(() => {
  //   if (isShutdown) {
  //     // When shutdown starts, play the static sound
  //     const staticAudio = new Audio('/sound/static.mp3')
  //     staticAudio.play()
  //     if (ambientAudioRef.current) ambientAudioRef.current.volume = 0 // Mute ambient
  //     // 2. Set a timer for the redirect. This happens completely outside the render path.
  //     const redirectTimer = setTimeout(() => {
  //       const shutdownAudio = new Audio('/sound/shutdown.mp3')
  //       shutdownAudio.play().then(() => {
  //         // Navigate AFTER the final sound plays
  //         window.location.href = '/finale'
  //       })
  //     }, 4000) // This must match the CSS animation duration
  //     // 3. Return a cleanup function for the timer
  //     return () => clearTimeout(redirectTimer)
  //   }
  // }, [isShutdown])

  // if (redirectToFinale) {
  //   // A clean way to navigate to the finale page
  //   // window.location.href = '/finale'
  //   console.log(`redirect to /finale `)
  //   return null // Render nothing while redirecting
  // }

  // useEffect(() => {
  //   let audio = new Audio('/sound/ambient.mp3')
  //   audio.loop = true
  //   audio.volume = 0.3
  //   ambientAudioRef.current = audio
  //   let isMounted = true
  //   const playAudio = async () => {
  //     try {
  //       await audio.play()
  //     } catch (error) {
  //       if (isMounted) console.error('Audio playback failed:', error)
  //     }
  //   }
  //   playAudio()
  //   return () => {
  //     isMounted = false
  //     audio.pause()
  //     audio.src = ''
  //   }
  // }, [])

  // useEffect(() => {
  //   if (selectedNode) {
  //     if (ambientAudioRef.current) ambientAudioRef.current.volume = 0.1
  //     const ping = new Audio('/sound/ping.mp3')
  //     ping.volume = 0.5
  //     ping.play()
  //   } else {
  //     if (ambientAudioRef.current) ambientAudioRef.current.volume = 0.3
  //   }
  // }, [selectedNode])

  return (
    <div className={styles.wrapper}>
      <Canvas camera={{ fov: 75, position: [0, 0, 150] }}>
        <ScrollControls pages={devHistoryData.length - 1} damping={0.3} enabled={universeState === 'flight'}>
          <Scene />
          <Bridge />
        </ScrollControls>
        <Scanline />
      </Canvas>

      {/* The finale text from your final page, appearing only in the void state */}
      {/* <div className={`${styles.finaleContainer} ${universeState === 'void' ? styles.isVisible : ''}`}>
        <h1>STATUS: STILL BUILDING.</h1>
        <div className={styles.links}>
          <a href="https://github.com/karwanleong" target="_blank">
            [ GitHub ]
          </a>
          <a href="https://www.linkedin.com/in/karwanleong" target="_blank">
            [ LinkedIn ]
          </a>
        </div>
      </div> */}
      {/* Hide DogEars during the finale */}
      {/* {universeState === 'flight' && (
        <>
          <DogEar href="/dossier" position="bottom-left" />
          <DogEar href="#" position="bottom-right" />
        </>
      )} */}
      <DescriptionOverlay />
      <DogEar href="/applications" position="bottom-left" aria-label="Return to applications" />
      <DogEar href="/finale" position="bottom-right" />
    </div>
  )
}

// <ambientLight intensity={0.5} />
// <directionalLight position={[10, 10, 5]} intensity={1} />
// {/* <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} /> */}
// <CometStars />
// <Nebula />
// <ScrollControls pages={devHistoryData.length} damping={0.3}>
//   {/* Render the Nodes */}
//   {devHistoryData.map((node) => (
//     // <DataCoreNode key={node.id} {...node} />
//     // <SingularityNode key={node.id} {...node} />
//     <WaypointNode key={node.id} {...node} />
//   ))}
//   {/* Render the Synapses */}
//   {devHistoryData.map((node) =>
//     node.connectsTo.map((targetId) => {
//       const targetNodeData = devHistoryData.find((n) => n.id === targetId)
//       if (!targetNodeData) return null
//       // The start and end points must be Vector3 for the curve calculation
//       const start = new Vector3(...node.position)
//       const end = new Vector3(...targetNodeData.position)
//       return (
//         <Synapse
//           key={`${node.id}-${targetId}`}
//           start={start}
//           end={end}
//           targetId={node.id} // This is the node it's connecting TO
//         />
//       )
//     })
//   )}
//   <CameraRig />
// </ScrollControls>
// <Scene />
// {/* <FinaleOverlay isVisible={launchProgress >= 0.95} /> */}
// <DescriptionOverlay />
// <DogEar href="/applications" position="bottom-left" aria-label="Return to applications" />
// {!isShutdown && (
//   // <DogEar href="#" onClick={(e) => e.preventDefault()} position="bottom-right" aria-label="View finale" />
//   // <DogEar href="/finale" position="bottom-right" aria-label="View finale" />
//   <DogEar href="#" onClick={(e) => e.preventDefault()} position="bottom-right" aria-label="View finale" />
// )}
